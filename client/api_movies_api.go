/*
IMDb-API

The IMDb-API Documentation. You need a <a href='/Identity/Account/Manage' target='_blank'><code>API Key</code></a> for testing APIs.<br/><a class='link' href='/API'>Back to API Tester</a>

API version: 1.8.1
*/

// Code generated by OpenAPI Generator (https://openapi-generator.tech); DO NOT EDIT.

package client

import (
	"bytes"
	"context"
	"io/ioutil"
	"net/http"
	"net/url"
	"strings"
)


// MoviesApiApiService MoviesApiApi service
type MoviesApiApiService service

type ApiAPIBoxOfficeAllTimeApiKeyGetRequest struct {
	ctx context.Context
	ApiService *MoviesApiApiService
	apiKey string
}

func (r ApiAPIBoxOfficeAllTimeApiKeyGetRequest) Execute() (*BoxOfficeAllTimeData, *http.Response, error) {
	return r.ApiService.APIBoxOfficeAllTimeApiKeyGetExecute(r)
}

/*
APIBoxOfficeAllTimeApiKeyGet Method for APIBoxOfficeAllTimeApiKeyGet

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param apiKey
 @return ApiAPIBoxOfficeAllTimeApiKeyGetRequest
*/
func (a *MoviesApiApiService) APIBoxOfficeAllTimeApiKeyGet(ctx context.Context, apiKey string) ApiAPIBoxOfficeAllTimeApiKeyGetRequest {
	return ApiAPIBoxOfficeAllTimeApiKeyGetRequest{
		ApiService: a,
		ctx: ctx,
		apiKey: apiKey,
	}
}

// Execute executes the request
//  @return BoxOfficeAllTimeData
func (a *MoviesApiApiService) APIBoxOfficeAllTimeApiKeyGetExecute(r ApiAPIBoxOfficeAllTimeApiKeyGetRequest) (*BoxOfficeAllTimeData, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *BoxOfficeAllTimeData
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "MoviesApiApiService.APIBoxOfficeAllTimeApiKeyGet")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/API/BoxOfficeAllTime/{apiKey}"
	localVarPath = strings.Replace(localVarPath, "{"+"apiKey"+"}", url.PathEscape(parameterToString(r.apiKey, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"text/plain", "application/json", "text/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiAPIBoxOfficeApiKeyGetRequest struct {
	ctx context.Context
	ApiService *MoviesApiApiService
	apiKey string
}

func (r ApiAPIBoxOfficeApiKeyGetRequest) Execute() (*BoxOfficeWeekendData, *http.Response, error) {
	return r.ApiService.APIBoxOfficeApiKeyGetExecute(r)
}

/*
APIBoxOfficeApiKeyGet Method for APIBoxOfficeApiKeyGet

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param apiKey
 @return ApiAPIBoxOfficeApiKeyGetRequest
*/
func (a *MoviesApiApiService) APIBoxOfficeApiKeyGet(ctx context.Context, apiKey string) ApiAPIBoxOfficeApiKeyGetRequest {
	return ApiAPIBoxOfficeApiKeyGetRequest{
		ApiService: a,
		ctx: ctx,
		apiKey: apiKey,
	}
}

// Execute executes the request
//  @return BoxOfficeWeekendData
func (a *MoviesApiApiService) APIBoxOfficeApiKeyGetExecute(r ApiAPIBoxOfficeApiKeyGetRequest) (*BoxOfficeWeekendData, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *BoxOfficeWeekendData
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "MoviesApiApiService.APIBoxOfficeApiKeyGet")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/API/BoxOffice/{apiKey}"
	localVarPath = strings.Replace(localVarPath, "{"+"apiKey"+"}", url.PathEscape(parameterToString(r.apiKey, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"text/plain", "application/json", "text/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiAPIComingSoonApiKeyGetRequest struct {
	ctx context.Context
	ApiService *MoviesApiApiService
	apiKey string
}

func (r ApiAPIComingSoonApiKeyGetRequest) Execute() (*NewMovieData, *http.Response, error) {
	return r.ApiService.APIComingSoonApiKeyGetExecute(r)
}

/*
APIComingSoonApiKeyGet Method for APIComingSoonApiKeyGet

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param apiKey
 @return ApiAPIComingSoonApiKeyGetRequest
*/
func (a *MoviesApiApiService) APIComingSoonApiKeyGet(ctx context.Context, apiKey string) ApiAPIComingSoonApiKeyGetRequest {
	return ApiAPIComingSoonApiKeyGetRequest{
		ApiService: a,
		ctx: ctx,
		apiKey: apiKey,
	}
}

// Execute executes the request
//  @return NewMovieData
func (a *MoviesApiApiService) APIComingSoonApiKeyGetExecute(r ApiAPIComingSoonApiKeyGetRequest) (*NewMovieData, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *NewMovieData
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "MoviesApiApiService.APIComingSoonApiKeyGet")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/API/ComingSoon/{apiKey}"
	localVarPath = strings.Replace(localVarPath, "{"+"apiKey"+"}", url.PathEscape(parameterToString(r.apiKey, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"text/plain", "application/json", "text/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiAPICompanyApiKeyIdGetRequest struct {
	ctx context.Context
	ApiService *MoviesApiApiService
	apiKey string
	id string
}

func (r ApiAPICompanyApiKeyIdGetRequest) Execute() (*CompanyData, *http.Response, error) {
	return r.ApiService.APICompanyApiKeyIdGetExecute(r)
}

/*
APICompanyApiKeyIdGet Method for APICompanyApiKeyIdGet

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param apiKey
 @param id
 @return ApiAPICompanyApiKeyIdGetRequest
*/
func (a *MoviesApiApiService) APICompanyApiKeyIdGet(ctx context.Context, apiKey string, id string) ApiAPICompanyApiKeyIdGetRequest {
	return ApiAPICompanyApiKeyIdGetRequest{
		ApiService: a,
		ctx: ctx,
		apiKey: apiKey,
		id: id,
	}
}

// Execute executes the request
//  @return CompanyData
func (a *MoviesApiApiService) APICompanyApiKeyIdGetExecute(r ApiAPICompanyApiKeyIdGetRequest) (*CompanyData, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *CompanyData
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "MoviesApiApiService.APICompanyApiKeyIdGet")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/API/Company/{apiKey}/{id}"
	localVarPath = strings.Replace(localVarPath, "{"+"apiKey"+"}", url.PathEscape(parameterToString(r.apiKey, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterToString(r.id, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"text/plain", "application/json", "text/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiAPIExternalSitesApiKeyIdGetRequest struct {
	ctx context.Context
	ApiService *MoviesApiApiService
	apiKey string
	id string
}

func (r ApiAPIExternalSitesApiKeyIdGetRequest) Execute() (*ExternalSiteData, *http.Response, error) {
	return r.ApiService.APIExternalSitesApiKeyIdGetExecute(r)
}

/*
APIExternalSitesApiKeyIdGet Method for APIExternalSitesApiKeyIdGet

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param apiKey
 @param id
 @return ApiAPIExternalSitesApiKeyIdGetRequest
*/
func (a *MoviesApiApiService) APIExternalSitesApiKeyIdGet(ctx context.Context, apiKey string, id string) ApiAPIExternalSitesApiKeyIdGetRequest {
	return ApiAPIExternalSitesApiKeyIdGetRequest{
		ApiService: a,
		ctx: ctx,
		apiKey: apiKey,
		id: id,
	}
}

// Execute executes the request
//  @return ExternalSiteData
func (a *MoviesApiApiService) APIExternalSitesApiKeyIdGetExecute(r ApiAPIExternalSitesApiKeyIdGetRequest) (*ExternalSiteData, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ExternalSiteData
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "MoviesApiApiService.APIExternalSitesApiKeyIdGet")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/API/ExternalSites/{apiKey}/{id}"
	localVarPath = strings.Replace(localVarPath, "{"+"apiKey"+"}", url.PathEscape(parameterToString(r.apiKey, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterToString(r.id, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"text/plain", "application/json", "text/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiAPIFAQApiKeyIdGetRequest struct {
	ctx context.Context
	ApiService *MoviesApiApiService
	apiKey string
	id string
}

func (r ApiAPIFAQApiKeyIdGetRequest) Execute() (*FAQData, *http.Response, error) {
	return r.ApiService.APIFAQApiKeyIdGetExecute(r)
}

/*
APIFAQApiKeyIdGet Method for APIFAQApiKeyIdGet

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param apiKey
 @param id
 @return ApiAPIFAQApiKeyIdGetRequest
*/
func (a *MoviesApiApiService) APIFAQApiKeyIdGet(ctx context.Context, apiKey string, id string) ApiAPIFAQApiKeyIdGetRequest {
	return ApiAPIFAQApiKeyIdGetRequest{
		ApiService: a,
		ctx: ctx,
		apiKey: apiKey,
		id: id,
	}
}

// Execute executes the request
//  @return FAQData
func (a *MoviesApiApiService) APIFAQApiKeyIdGetExecute(r ApiAPIFAQApiKeyIdGetRequest) (*FAQData, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *FAQData
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "MoviesApiApiService.APIFAQApiKeyIdGet")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/API/FAQ/{apiKey}/{id}"
	localVarPath = strings.Replace(localVarPath, "{"+"apiKey"+"}", url.PathEscape(parameterToString(r.apiKey, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterToString(r.id, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"text/plain", "application/json", "text/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiAPIFullCastApiKeyIdGetRequest struct {
	ctx context.Context
	ApiService *MoviesApiApiService
	apiKey string
	id string
}

func (r ApiAPIFullCastApiKeyIdGetRequest) Execute() (*FullCastData, *http.Response, error) {
	return r.ApiService.APIFullCastApiKeyIdGetExecute(r)
}

/*
APIFullCastApiKeyIdGet Method for APIFullCastApiKeyIdGet

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param apiKey
 @param id
 @return ApiAPIFullCastApiKeyIdGetRequest
*/
func (a *MoviesApiApiService) APIFullCastApiKeyIdGet(ctx context.Context, apiKey string, id string) ApiAPIFullCastApiKeyIdGetRequest {
	return ApiAPIFullCastApiKeyIdGetRequest{
		ApiService: a,
		ctx: ctx,
		apiKey: apiKey,
		id: id,
	}
}

// Execute executes the request
//  @return FullCastData
func (a *MoviesApiApiService) APIFullCastApiKeyIdGetExecute(r ApiAPIFullCastApiKeyIdGetRequest) (*FullCastData, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *FullCastData
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "MoviesApiApiService.APIFullCastApiKeyIdGet")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/API/FullCast/{apiKey}/{id}"
	localVarPath = strings.Replace(localVarPath, "{"+"apiKey"+"}", url.PathEscape(parameterToString(r.apiKey, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterToString(r.id, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"text/plain", "application/json", "text/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiAPIIMDbListApiKeyIdGetRequest struct {
	ctx context.Context
	ApiService *MoviesApiApiService
	apiKey string
	id string
}

func (r ApiAPIIMDbListApiKeyIdGetRequest) Execute() (*IMDbListData, *http.Response, error) {
	return r.ApiService.APIIMDbListApiKeyIdGetExecute(r)
}

/*
APIIMDbListApiKeyIdGet Method for APIIMDbListApiKeyIdGet

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param apiKey
 @param id
 @return ApiAPIIMDbListApiKeyIdGetRequest
*/
func (a *MoviesApiApiService) APIIMDbListApiKeyIdGet(ctx context.Context, apiKey string, id string) ApiAPIIMDbListApiKeyIdGetRequest {
	return ApiAPIIMDbListApiKeyIdGetRequest{
		ApiService: a,
		ctx: ctx,
		apiKey: apiKey,
		id: id,
	}
}

// Execute executes the request
//  @return IMDbListData
func (a *MoviesApiApiService) APIIMDbListApiKeyIdGetExecute(r ApiAPIIMDbListApiKeyIdGetRequest) (*IMDbListData, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *IMDbListData
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "MoviesApiApiService.APIIMDbListApiKeyIdGet")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/API/IMDbList/{apiKey}/{id}"
	localVarPath = strings.Replace(localVarPath, "{"+"apiKey"+"}", url.PathEscape(parameterToString(r.apiKey, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterToString(r.id, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"text/plain", "application/json", "text/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiAPIImagesApiKeyIdGetRequest struct {
	ctx context.Context
	ApiService *MoviesApiApiService
	id string
	apiKey string
}

func (r ApiAPIImagesApiKeyIdGetRequest) Execute() (*ImageData, *http.Response, error) {
	return r.ApiService.APIImagesApiKeyIdGetExecute(r)
}

/*
APIImagesApiKeyIdGet Method for APIImagesApiKeyIdGet

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id
 @param apiKey
 @return ApiAPIImagesApiKeyIdGetRequest
*/
func (a *MoviesApiApiService) APIImagesApiKeyIdGet(ctx context.Context, id string, apiKey string) ApiAPIImagesApiKeyIdGetRequest {
	return ApiAPIImagesApiKeyIdGetRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
		apiKey: apiKey,
	}
}

// Execute executes the request
//  @return ImageData
func (a *MoviesApiApiService) APIImagesApiKeyIdGetExecute(r ApiAPIImagesApiKeyIdGetRequest) (*ImageData, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ImageData
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "MoviesApiApiService.APIImagesApiKeyIdGet")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/API/Images/{apiKey}/{id}"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterToString(r.id, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"apiKey"+"}", url.PathEscape(parameterToString(r.apiKey, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"text/plain", "application/json", "text/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiAPIImagesApiKeyIdOptionsGetRequest struct {
	ctx context.Context
	ApiService *MoviesApiApiService
	apiKey string
	id string
	options string
}

func (r ApiAPIImagesApiKeyIdOptionsGetRequest) Execute() (*ImageData, *http.Response, error) {
	return r.ApiService.APIImagesApiKeyIdOptionsGetExecute(r)
}

/*
APIImagesApiKeyIdOptionsGet Method for APIImagesApiKeyIdOptionsGet

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param apiKey
 @param id
 @param options
 @return ApiAPIImagesApiKeyIdOptionsGetRequest
*/
func (a *MoviesApiApiService) APIImagesApiKeyIdOptionsGet(ctx context.Context, apiKey string, id string, options string) ApiAPIImagesApiKeyIdOptionsGetRequest {
	return ApiAPIImagesApiKeyIdOptionsGetRequest{
		ApiService: a,
		ctx: ctx,
		apiKey: apiKey,
		id: id,
		options: options,
	}
}

// Execute executes the request
//  @return ImageData
func (a *MoviesApiApiService) APIImagesApiKeyIdOptionsGetExecute(r ApiAPIImagesApiKeyIdOptionsGetRequest) (*ImageData, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ImageData
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "MoviesApiApiService.APIImagesApiKeyIdOptionsGet")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/API/Images/{apiKey}/{id}/{options}"
	localVarPath = strings.Replace(localVarPath, "{"+"apiKey"+"}", url.PathEscape(parameterToString(r.apiKey, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterToString(r.id, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"options"+"}", url.PathEscape(parameterToString(r.options, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"text/plain", "application/json", "text/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiAPIInTheatersApiKeyGetRequest struct {
	ctx context.Context
	ApiService *MoviesApiApiService
	apiKey string
}

func (r ApiAPIInTheatersApiKeyGetRequest) Execute() (*NewMovieData, *http.Response, error) {
	return r.ApiService.APIInTheatersApiKeyGetExecute(r)
}

/*
APIInTheatersApiKeyGet Method for APIInTheatersApiKeyGet

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param apiKey
 @return ApiAPIInTheatersApiKeyGetRequest
*/
func (a *MoviesApiApiService) APIInTheatersApiKeyGet(ctx context.Context, apiKey string) ApiAPIInTheatersApiKeyGetRequest {
	return ApiAPIInTheatersApiKeyGetRequest{
		ApiService: a,
		ctx: ctx,
		apiKey: apiKey,
	}
}

// Execute executes the request
//  @return NewMovieData
func (a *MoviesApiApiService) APIInTheatersApiKeyGetExecute(r ApiAPIInTheatersApiKeyGetRequest) (*NewMovieData, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *NewMovieData
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "MoviesApiApiService.APIInTheatersApiKeyGet")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/API/InTheaters/{apiKey}"
	localVarPath = strings.Replace(localVarPath, "{"+"apiKey"+"}", url.PathEscape(parameterToString(r.apiKey, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"text/plain", "application/json", "text/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiAPIKeywordApiKeyIdGetRequest struct {
	ctx context.Context
	ApiService *MoviesApiApiService
	apiKey string
	id string
}

func (r ApiAPIKeywordApiKeyIdGetRequest) Execute() (*KeywordData, *http.Response, error) {
	return r.ApiService.APIKeywordApiKeyIdGetExecute(r)
}

/*
APIKeywordApiKeyIdGet Method for APIKeywordApiKeyIdGet

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param apiKey
 @param id
 @return ApiAPIKeywordApiKeyIdGetRequest
*/
func (a *MoviesApiApiService) APIKeywordApiKeyIdGet(ctx context.Context, apiKey string, id string) ApiAPIKeywordApiKeyIdGetRequest {
	return ApiAPIKeywordApiKeyIdGetRequest{
		ApiService: a,
		ctx: ctx,
		apiKey: apiKey,
		id: id,
	}
}

// Execute executes the request
//  @return KeywordData
func (a *MoviesApiApiService) APIKeywordApiKeyIdGetExecute(r ApiAPIKeywordApiKeyIdGetRequest) (*KeywordData, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *KeywordData
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "MoviesApiApiService.APIKeywordApiKeyIdGet")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/API/Keyword/{apiKey}/{id}"
	localVarPath = strings.Replace(localVarPath, "{"+"apiKey"+"}", url.PathEscape(parameterToString(r.apiKey, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterToString(r.id, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"text/plain", "application/json", "text/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiAPIMetacriticReviewsApiKeyIdGetRequest struct {
	ctx context.Context
	ApiService *MoviesApiApiService
	apiKey string
	id string
}

func (r ApiAPIMetacriticReviewsApiKeyIdGetRequest) Execute() (*MetacriticReviewData, *http.Response, error) {
	return r.ApiService.APIMetacriticReviewsApiKeyIdGetExecute(r)
}

/*
APIMetacriticReviewsApiKeyIdGet Method for APIMetacriticReviewsApiKeyIdGet

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param apiKey
 @param id
 @return ApiAPIMetacriticReviewsApiKeyIdGetRequest
*/
func (a *MoviesApiApiService) APIMetacriticReviewsApiKeyIdGet(ctx context.Context, apiKey string, id string) ApiAPIMetacriticReviewsApiKeyIdGetRequest {
	return ApiAPIMetacriticReviewsApiKeyIdGetRequest{
		ApiService: a,
		ctx: ctx,
		apiKey: apiKey,
		id: id,
	}
}

// Execute executes the request
//  @return MetacriticReviewData
func (a *MoviesApiApiService) APIMetacriticReviewsApiKeyIdGetExecute(r ApiAPIMetacriticReviewsApiKeyIdGetRequest) (*MetacriticReviewData, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *MetacriticReviewData
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "MoviesApiApiService.APIMetacriticReviewsApiKeyIdGet")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/API/MetacriticReviews/{apiKey}/{id}"
	localVarPath = strings.Replace(localVarPath, "{"+"apiKey"+"}", url.PathEscape(parameterToString(r.apiKey, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterToString(r.id, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"text/plain", "application/json", "text/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiAPIMostPopularMoviesApiKeyGetRequest struct {
	ctx context.Context
	ApiService *MoviesApiApiService
	apiKey string
}

func (r ApiAPIMostPopularMoviesApiKeyGetRequest) Execute() (*MostPopularData, *http.Response, error) {
	return r.ApiService.APIMostPopularMoviesApiKeyGetExecute(r)
}

/*
APIMostPopularMoviesApiKeyGet Method for APIMostPopularMoviesApiKeyGet

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param apiKey
 @return ApiAPIMostPopularMoviesApiKeyGetRequest
*/
func (a *MoviesApiApiService) APIMostPopularMoviesApiKeyGet(ctx context.Context, apiKey string) ApiAPIMostPopularMoviesApiKeyGetRequest {
	return ApiAPIMostPopularMoviesApiKeyGetRequest{
		ApiService: a,
		ctx: ctx,
		apiKey: apiKey,
	}
}

// Execute executes the request
//  @return MostPopularData
func (a *MoviesApiApiService) APIMostPopularMoviesApiKeyGetExecute(r ApiAPIMostPopularMoviesApiKeyGetRequest) (*MostPopularData, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *MostPopularData
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "MoviesApiApiService.APIMostPopularMoviesApiKeyGet")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/API/MostPopularMovies/{apiKey}"
	localVarPath = strings.Replace(localVarPath, "{"+"apiKey"+"}", url.PathEscape(parameterToString(r.apiKey, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"text/plain", "application/json", "text/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiAPIMostPopularTVsApiKeyGetRequest struct {
	ctx context.Context
	ApiService *MoviesApiApiService
	apiKey string
}

func (r ApiAPIMostPopularTVsApiKeyGetRequest) Execute() (*MostPopularData, *http.Response, error) {
	return r.ApiService.APIMostPopularTVsApiKeyGetExecute(r)
}

/*
APIMostPopularTVsApiKeyGet Method for APIMostPopularTVsApiKeyGet

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param apiKey
 @return ApiAPIMostPopularTVsApiKeyGetRequest
*/
func (a *MoviesApiApiService) APIMostPopularTVsApiKeyGet(ctx context.Context, apiKey string) ApiAPIMostPopularTVsApiKeyGetRequest {
	return ApiAPIMostPopularTVsApiKeyGetRequest{
		ApiService: a,
		ctx: ctx,
		apiKey: apiKey,
	}
}

// Execute executes the request
//  @return MostPopularData
func (a *MoviesApiApiService) APIMostPopularTVsApiKeyGetExecute(r ApiAPIMostPopularTVsApiKeyGetRequest) (*MostPopularData, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *MostPopularData
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "MoviesApiApiService.APIMostPopularTVsApiKeyGet")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/API/MostPopularTVs/{apiKey}"
	localVarPath = strings.Replace(localVarPath, "{"+"apiKey"+"}", url.PathEscape(parameterToString(r.apiKey, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"text/plain", "application/json", "text/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiAPINameApiKeyIdGetRequest struct {
	ctx context.Context
	ApiService *MoviesApiApiService
	apiKey string
	id string
}

func (r ApiAPINameApiKeyIdGetRequest) Execute() (*NameData, *http.Response, error) {
	return r.ApiService.APINameApiKeyIdGetExecute(r)
}

/*
APINameApiKeyIdGet Method for APINameApiKeyIdGet

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param apiKey
 @param id
 @return ApiAPINameApiKeyIdGetRequest
*/
func (a *MoviesApiApiService) APINameApiKeyIdGet(ctx context.Context, apiKey string, id string) ApiAPINameApiKeyIdGetRequest {
	return ApiAPINameApiKeyIdGetRequest{
		ApiService: a,
		ctx: ctx,
		apiKey: apiKey,
		id: id,
	}
}

// Execute executes the request
//  @return NameData
func (a *MoviesApiApiService) APINameApiKeyIdGetExecute(r ApiAPINameApiKeyIdGetRequest) (*NameData, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *NameData
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "MoviesApiApiService.APINameApiKeyIdGet")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/API/Name/{apiKey}/{id}"
	localVarPath = strings.Replace(localVarPath, "{"+"apiKey"+"}", url.PathEscape(parameterToString(r.apiKey, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterToString(r.id, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"text/plain", "application/json", "text/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiAPIPostersApiKeyIdGetRequest struct {
	ctx context.Context
	ApiService *MoviesApiApiService
	apiKey string
	id string
}

func (r ApiAPIPostersApiKeyIdGetRequest) Execute() (*PosterData, *http.Response, error) {
	return r.ApiService.APIPostersApiKeyIdGetExecute(r)
}

/*
APIPostersApiKeyIdGet Method for APIPostersApiKeyIdGet

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param apiKey
 @param id
 @return ApiAPIPostersApiKeyIdGetRequest
*/
func (a *MoviesApiApiService) APIPostersApiKeyIdGet(ctx context.Context, apiKey string, id string) ApiAPIPostersApiKeyIdGetRequest {
	return ApiAPIPostersApiKeyIdGetRequest{
		ApiService: a,
		ctx: ctx,
		apiKey: apiKey,
		id: id,
	}
}

// Execute executes the request
//  @return PosterData
func (a *MoviesApiApiService) APIPostersApiKeyIdGetExecute(r ApiAPIPostersApiKeyIdGetRequest) (*PosterData, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *PosterData
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "MoviesApiApiService.APIPostersApiKeyIdGet")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/API/Posters/{apiKey}/{id}"
	localVarPath = strings.Replace(localVarPath, "{"+"apiKey"+"}", url.PathEscape(parameterToString(r.apiKey, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterToString(r.id, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"text/plain", "application/json", "text/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiAPIRatingsApiKeyIdGetRequest struct {
	ctx context.Context
	ApiService *MoviesApiApiService
	apiKey string
	id string
}

func (r ApiAPIRatingsApiKeyIdGetRequest) Execute() (*RatingData, *http.Response, error) {
	return r.ApiService.APIRatingsApiKeyIdGetExecute(r)
}

/*
APIRatingsApiKeyIdGet Method for APIRatingsApiKeyIdGet

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param apiKey
 @param id
 @return ApiAPIRatingsApiKeyIdGetRequest
*/
func (a *MoviesApiApiService) APIRatingsApiKeyIdGet(ctx context.Context, apiKey string, id string) ApiAPIRatingsApiKeyIdGetRequest {
	return ApiAPIRatingsApiKeyIdGetRequest{
		ApiService: a,
		ctx: ctx,
		apiKey: apiKey,
		id: id,
	}
}

// Execute executes the request
//  @return RatingData
func (a *MoviesApiApiService) APIRatingsApiKeyIdGetExecute(r ApiAPIRatingsApiKeyIdGetRequest) (*RatingData, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *RatingData
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "MoviesApiApiService.APIRatingsApiKeyIdGet")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/API/Ratings/{apiKey}/{id}"
	localVarPath = strings.Replace(localVarPath, "{"+"apiKey"+"}", url.PathEscape(parameterToString(r.apiKey, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterToString(r.id, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"text/plain", "application/json", "text/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiAPIReviewsApiKeyIdGetRequest struct {
	ctx context.Context
	ApiService *MoviesApiApiService
	apiKey string
	id string
}

func (r ApiAPIReviewsApiKeyIdGetRequest) Execute() (*ReviewData, *http.Response, error) {
	return r.ApiService.APIReviewsApiKeyIdGetExecute(r)
}

/*
APIReviewsApiKeyIdGet Method for APIReviewsApiKeyIdGet

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param apiKey
 @param id
 @return ApiAPIReviewsApiKeyIdGetRequest
*/
func (a *MoviesApiApiService) APIReviewsApiKeyIdGet(ctx context.Context, apiKey string, id string) ApiAPIReviewsApiKeyIdGetRequest {
	return ApiAPIReviewsApiKeyIdGetRequest{
		ApiService: a,
		ctx: ctx,
		apiKey: apiKey,
		id: id,
	}
}

// Execute executes the request
//  @return ReviewData
func (a *MoviesApiApiService) APIReviewsApiKeyIdGetExecute(r ApiAPIReviewsApiKeyIdGetRequest) (*ReviewData, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ReviewData
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "MoviesApiApiService.APIReviewsApiKeyIdGet")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/API/Reviews/{apiKey}/{id}"
	localVarPath = strings.Replace(localVarPath, "{"+"apiKey"+"}", url.PathEscape(parameterToString(r.apiKey, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterToString(r.id, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"text/plain", "application/json", "text/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiAPISearchAllApiKeyExpressionGetRequest struct {
	ctx context.Context
	ApiService *MoviesApiApiService
	apiKey string
	expression string
}

func (r ApiAPISearchAllApiKeyExpressionGetRequest) Execute() (*SearchData, *http.Response, error) {
	return r.ApiService.APISearchAllApiKeyExpressionGetExecute(r)
}

/*
APISearchAllApiKeyExpressionGet Method for APISearchAllApiKeyExpressionGet

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param apiKey
 @param expression
 @return ApiAPISearchAllApiKeyExpressionGetRequest
*/
func (a *MoviesApiApiService) APISearchAllApiKeyExpressionGet(ctx context.Context, apiKey string, expression string) ApiAPISearchAllApiKeyExpressionGetRequest {
	return ApiAPISearchAllApiKeyExpressionGetRequest{
		ApiService: a,
		ctx: ctx,
		apiKey: apiKey,
		expression: expression,
	}
}

// Execute executes the request
//  @return SearchData
func (a *MoviesApiApiService) APISearchAllApiKeyExpressionGetExecute(r ApiAPISearchAllApiKeyExpressionGetRequest) (*SearchData, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *SearchData
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "MoviesApiApiService.APISearchAllApiKeyExpressionGet")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/API/SearchAll/{apiKey}/{expression}"
	localVarPath = strings.Replace(localVarPath, "{"+"apiKey"+"}", url.PathEscape(parameterToString(r.apiKey, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"expression"+"}", url.PathEscape(parameterToString(r.expression, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"text/plain", "application/json", "text/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiAPISearchApiKeyExpressionGetRequest struct {
	ctx context.Context
	ApiService *MoviesApiApiService
	apiKey string
	expression string
}

func (r ApiAPISearchApiKeyExpressionGetRequest) Execute() (*SearchData, *http.Response, error) {
	return r.ApiService.APISearchApiKeyExpressionGetExecute(r)
}

/*
APISearchApiKeyExpressionGet Method for APISearchApiKeyExpressionGet

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param apiKey
 @param expression
 @return ApiAPISearchApiKeyExpressionGetRequest
*/
func (a *MoviesApiApiService) APISearchApiKeyExpressionGet(ctx context.Context, apiKey string, expression string) ApiAPISearchApiKeyExpressionGetRequest {
	return ApiAPISearchApiKeyExpressionGetRequest{
		ApiService: a,
		ctx: ctx,
		apiKey: apiKey,
		expression: expression,
	}
}

// Execute executes the request
//  @return SearchData
func (a *MoviesApiApiService) APISearchApiKeyExpressionGetExecute(r ApiAPISearchApiKeyExpressionGetRequest) (*SearchData, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *SearchData
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "MoviesApiApiService.APISearchApiKeyExpressionGet")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/API/Search/{apiKey}/{expression}"
	localVarPath = strings.Replace(localVarPath, "{"+"apiKey"+"}", url.PathEscape(parameterToString(r.apiKey, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"expression"+"}", url.PathEscape(parameterToString(r.expression, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"text/plain", "application/json", "text/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiAPISearchCompanyApiKeyExpressionGetRequest struct {
	ctx context.Context
	ApiService *MoviesApiApiService
	apiKey string
	expression string
}

func (r ApiAPISearchCompanyApiKeyExpressionGetRequest) Execute() (*SearchData, *http.Response, error) {
	return r.ApiService.APISearchCompanyApiKeyExpressionGetExecute(r)
}

/*
APISearchCompanyApiKeyExpressionGet Method for APISearchCompanyApiKeyExpressionGet

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param apiKey
 @param expression
 @return ApiAPISearchCompanyApiKeyExpressionGetRequest
*/
func (a *MoviesApiApiService) APISearchCompanyApiKeyExpressionGet(ctx context.Context, apiKey string, expression string) ApiAPISearchCompanyApiKeyExpressionGetRequest {
	return ApiAPISearchCompanyApiKeyExpressionGetRequest{
		ApiService: a,
		ctx: ctx,
		apiKey: apiKey,
		expression: expression,
	}
}

// Execute executes the request
//  @return SearchData
func (a *MoviesApiApiService) APISearchCompanyApiKeyExpressionGetExecute(r ApiAPISearchCompanyApiKeyExpressionGetRequest) (*SearchData, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *SearchData
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "MoviesApiApiService.APISearchCompanyApiKeyExpressionGet")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/API/SearchCompany/{apiKey}/{expression}"
	localVarPath = strings.Replace(localVarPath, "{"+"apiKey"+"}", url.PathEscape(parameterToString(r.apiKey, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"expression"+"}", url.PathEscape(parameterToString(r.expression, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"text/plain", "application/json", "text/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiAPISearchEpisodeApiKeyExpressionGetRequest struct {
	ctx context.Context
	ApiService *MoviesApiApiService
	apiKey string
	expression string
}

func (r ApiAPISearchEpisodeApiKeyExpressionGetRequest) Execute() (*SearchData, *http.Response, error) {
	return r.ApiService.APISearchEpisodeApiKeyExpressionGetExecute(r)
}

/*
APISearchEpisodeApiKeyExpressionGet Method for APISearchEpisodeApiKeyExpressionGet

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param apiKey
 @param expression
 @return ApiAPISearchEpisodeApiKeyExpressionGetRequest
*/
func (a *MoviesApiApiService) APISearchEpisodeApiKeyExpressionGet(ctx context.Context, apiKey string, expression string) ApiAPISearchEpisodeApiKeyExpressionGetRequest {
	return ApiAPISearchEpisodeApiKeyExpressionGetRequest{
		ApiService: a,
		ctx: ctx,
		apiKey: apiKey,
		expression: expression,
	}
}

// Execute executes the request
//  @return SearchData
func (a *MoviesApiApiService) APISearchEpisodeApiKeyExpressionGetExecute(r ApiAPISearchEpisodeApiKeyExpressionGetRequest) (*SearchData, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *SearchData
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "MoviesApiApiService.APISearchEpisodeApiKeyExpressionGet")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/API/SearchEpisode/{apiKey}/{expression}"
	localVarPath = strings.Replace(localVarPath, "{"+"apiKey"+"}", url.PathEscape(parameterToString(r.apiKey, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"expression"+"}", url.PathEscape(parameterToString(r.expression, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"text/plain", "application/json", "text/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiAPISearchKeywordApiKeyExpressionGetRequest struct {
	ctx context.Context
	ApiService *MoviesApiApiService
	apiKey string
	expression string
}

func (r ApiAPISearchKeywordApiKeyExpressionGetRequest) Execute() (*SearchData, *http.Response, error) {
	return r.ApiService.APISearchKeywordApiKeyExpressionGetExecute(r)
}

/*
APISearchKeywordApiKeyExpressionGet Method for APISearchKeywordApiKeyExpressionGet

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param apiKey
 @param expression
 @return ApiAPISearchKeywordApiKeyExpressionGetRequest
*/
func (a *MoviesApiApiService) APISearchKeywordApiKeyExpressionGet(ctx context.Context, apiKey string, expression string) ApiAPISearchKeywordApiKeyExpressionGetRequest {
	return ApiAPISearchKeywordApiKeyExpressionGetRequest{
		ApiService: a,
		ctx: ctx,
		apiKey: apiKey,
		expression: expression,
	}
}

// Execute executes the request
//  @return SearchData
func (a *MoviesApiApiService) APISearchKeywordApiKeyExpressionGetExecute(r ApiAPISearchKeywordApiKeyExpressionGetRequest) (*SearchData, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *SearchData
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "MoviesApiApiService.APISearchKeywordApiKeyExpressionGet")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/API/SearchKeyword/{apiKey}/{expression}"
	localVarPath = strings.Replace(localVarPath, "{"+"apiKey"+"}", url.PathEscape(parameterToString(r.apiKey, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"expression"+"}", url.PathEscape(parameterToString(r.expression, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"text/plain", "application/json", "text/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiAPISearchMovieApiKeyExpressionGetRequest struct {
	ctx context.Context
	ApiService *MoviesApiApiService
	apiKey string
	expression string
}

func (r ApiAPISearchMovieApiKeyExpressionGetRequest) Execute() (*SearchData, *http.Response, error) {
	return r.ApiService.APISearchMovieApiKeyExpressionGetExecute(r)
}

/*
APISearchMovieApiKeyExpressionGet Method for APISearchMovieApiKeyExpressionGet

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param apiKey
 @param expression
 @return ApiAPISearchMovieApiKeyExpressionGetRequest
*/
func (a *MoviesApiApiService) APISearchMovieApiKeyExpressionGet(ctx context.Context, apiKey string, expression string) ApiAPISearchMovieApiKeyExpressionGetRequest {
	return ApiAPISearchMovieApiKeyExpressionGetRequest{
		ApiService: a,
		ctx: ctx,
		apiKey: apiKey,
		expression: expression,
	}
}

// Execute executes the request
//  @return SearchData
func (a *MoviesApiApiService) APISearchMovieApiKeyExpressionGetExecute(r ApiAPISearchMovieApiKeyExpressionGetRequest) (*SearchData, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *SearchData
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "MoviesApiApiService.APISearchMovieApiKeyExpressionGet")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/API/SearchMovie/{apiKey}/{expression}"
	localVarPath = strings.Replace(localVarPath, "{"+"apiKey"+"}", url.PathEscape(parameterToString(r.apiKey, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"expression"+"}", url.PathEscape(parameterToString(r.expression, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"text/plain", "application/json", "text/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiAPISearchNameApiKeyExpressionGetRequest struct {
	ctx context.Context
	ApiService *MoviesApiApiService
	apiKey string
	expression string
}

func (r ApiAPISearchNameApiKeyExpressionGetRequest) Execute() (*SearchData, *http.Response, error) {
	return r.ApiService.APISearchNameApiKeyExpressionGetExecute(r)
}

/*
APISearchNameApiKeyExpressionGet Method for APISearchNameApiKeyExpressionGet

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param apiKey
 @param expression
 @return ApiAPISearchNameApiKeyExpressionGetRequest
*/
func (a *MoviesApiApiService) APISearchNameApiKeyExpressionGet(ctx context.Context, apiKey string, expression string) ApiAPISearchNameApiKeyExpressionGetRequest {
	return ApiAPISearchNameApiKeyExpressionGetRequest{
		ApiService: a,
		ctx: ctx,
		apiKey: apiKey,
		expression: expression,
	}
}

// Execute executes the request
//  @return SearchData
func (a *MoviesApiApiService) APISearchNameApiKeyExpressionGetExecute(r ApiAPISearchNameApiKeyExpressionGetRequest) (*SearchData, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *SearchData
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "MoviesApiApiService.APISearchNameApiKeyExpressionGet")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/API/SearchName/{apiKey}/{expression}"
	localVarPath = strings.Replace(localVarPath, "{"+"apiKey"+"}", url.PathEscape(parameterToString(r.apiKey, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"expression"+"}", url.PathEscape(parameterToString(r.expression, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"text/plain", "application/json", "text/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiAPISearchSeriesApiKeyExpressionGetRequest struct {
	ctx context.Context
	ApiService *MoviesApiApiService
	apiKey string
	expression string
}

func (r ApiAPISearchSeriesApiKeyExpressionGetRequest) Execute() (*SearchData, *http.Response, error) {
	return r.ApiService.APISearchSeriesApiKeyExpressionGetExecute(r)
}

/*
APISearchSeriesApiKeyExpressionGet Method for APISearchSeriesApiKeyExpressionGet

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param apiKey
 @param expression
 @return ApiAPISearchSeriesApiKeyExpressionGetRequest
*/
func (a *MoviesApiApiService) APISearchSeriesApiKeyExpressionGet(ctx context.Context, apiKey string, expression string) ApiAPISearchSeriesApiKeyExpressionGetRequest {
	return ApiAPISearchSeriesApiKeyExpressionGetRequest{
		ApiService: a,
		ctx: ctx,
		apiKey: apiKey,
		expression: expression,
	}
}

// Execute executes the request
//  @return SearchData
func (a *MoviesApiApiService) APISearchSeriesApiKeyExpressionGetExecute(r ApiAPISearchSeriesApiKeyExpressionGetRequest) (*SearchData, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *SearchData
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "MoviesApiApiService.APISearchSeriesApiKeyExpressionGet")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/API/SearchSeries/{apiKey}/{expression}"
	localVarPath = strings.Replace(localVarPath, "{"+"apiKey"+"}", url.PathEscape(parameterToString(r.apiKey, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"expression"+"}", url.PathEscape(parameterToString(r.expression, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"text/plain", "application/json", "text/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiAPISearchTitleApiKeyExpressionGetRequest struct {
	ctx context.Context
	ApiService *MoviesApiApiService
	apiKey string
	expression string
}

func (r ApiAPISearchTitleApiKeyExpressionGetRequest) Execute() (*SearchData, *http.Response, error) {
	return r.ApiService.APISearchTitleApiKeyExpressionGetExecute(r)
}

/*
APISearchTitleApiKeyExpressionGet Method for APISearchTitleApiKeyExpressionGet

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param apiKey
 @param expression
 @return ApiAPISearchTitleApiKeyExpressionGetRequest
*/
func (a *MoviesApiApiService) APISearchTitleApiKeyExpressionGet(ctx context.Context, apiKey string, expression string) ApiAPISearchTitleApiKeyExpressionGetRequest {
	return ApiAPISearchTitleApiKeyExpressionGetRequest{
		ApiService: a,
		ctx: ctx,
		apiKey: apiKey,
		expression: expression,
	}
}

// Execute executes the request
//  @return SearchData
func (a *MoviesApiApiService) APISearchTitleApiKeyExpressionGetExecute(r ApiAPISearchTitleApiKeyExpressionGetRequest) (*SearchData, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *SearchData
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "MoviesApiApiService.APISearchTitleApiKeyExpressionGet")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/API/SearchTitle/{apiKey}/{expression}"
	localVarPath = strings.Replace(localVarPath, "{"+"apiKey"+"}", url.PathEscape(parameterToString(r.apiKey, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"expression"+"}", url.PathEscape(parameterToString(r.expression, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"text/plain", "application/json", "text/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiAPISeasonEpisodesApiKeyIdSeasonNumberGetRequest struct {
	ctx context.Context
	ApiService *MoviesApiApiService
	apiKey string
	id string
	seasonNumber string
}

func (r ApiAPISeasonEpisodesApiKeyIdSeasonNumberGetRequest) Execute() (*SeasonEpisodeData, *http.Response, error) {
	return r.ApiService.APISeasonEpisodesApiKeyIdSeasonNumberGetExecute(r)
}

/*
APISeasonEpisodesApiKeyIdSeasonNumberGet Method for APISeasonEpisodesApiKeyIdSeasonNumberGet

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param apiKey
 @param id
 @param seasonNumber
 @return ApiAPISeasonEpisodesApiKeyIdSeasonNumberGetRequest
*/
func (a *MoviesApiApiService) APISeasonEpisodesApiKeyIdSeasonNumberGet(ctx context.Context, apiKey string, id string, seasonNumber string) ApiAPISeasonEpisodesApiKeyIdSeasonNumberGetRequest {
	return ApiAPISeasonEpisodesApiKeyIdSeasonNumberGetRequest{
		ApiService: a,
		ctx: ctx,
		apiKey: apiKey,
		id: id,
		seasonNumber: seasonNumber,
	}
}

// Execute executes the request
//  @return SeasonEpisodeData
func (a *MoviesApiApiService) APISeasonEpisodesApiKeyIdSeasonNumberGetExecute(r ApiAPISeasonEpisodesApiKeyIdSeasonNumberGetRequest) (*SeasonEpisodeData, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *SeasonEpisodeData
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "MoviesApiApiService.APISeasonEpisodesApiKeyIdSeasonNumberGet")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/API/SeasonEpisodes/{apiKey}/{id}/{seasonNumber}"
	localVarPath = strings.Replace(localVarPath, "{"+"apiKey"+"}", url.PathEscape(parameterToString(r.apiKey, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterToString(r.id, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"seasonNumber"+"}", url.PathEscape(parameterToString(r.seasonNumber, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"text/plain", "application/json", "text/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiAPISubtitlesApiKeyIdGetRequest struct {
	ctx context.Context
	ApiService *MoviesApiApiService
	apiKey string
	id string
}

func (r ApiAPISubtitlesApiKeyIdGetRequest) Execute() (*SubtitleData, *http.Response, error) {
	return r.ApiService.APISubtitlesApiKeyIdGetExecute(r)
}

/*
APISubtitlesApiKeyIdGet Method for APISubtitlesApiKeyIdGet

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param apiKey
 @param id
 @return ApiAPISubtitlesApiKeyIdGetRequest
*/
func (a *MoviesApiApiService) APISubtitlesApiKeyIdGet(ctx context.Context, apiKey string, id string) ApiAPISubtitlesApiKeyIdGetRequest {
	return ApiAPISubtitlesApiKeyIdGetRequest{
		ApiService: a,
		ctx: ctx,
		apiKey: apiKey,
		id: id,
	}
}

// Execute executes the request
//  @return SubtitleData
func (a *MoviesApiApiService) APISubtitlesApiKeyIdGetExecute(r ApiAPISubtitlesApiKeyIdGetRequest) (*SubtitleData, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *SubtitleData
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "MoviesApiApiService.APISubtitlesApiKeyIdGet")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/API/Subtitles/{apiKey}/{id}"
	localVarPath = strings.Replace(localVarPath, "{"+"apiKey"+"}", url.PathEscape(parameterToString(r.apiKey, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterToString(r.id, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"text/plain", "application/json", "text/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiAPISubtitlesApiKeyIdSeasonNumberGetRequest struct {
	ctx context.Context
	ApiService *MoviesApiApiService
	apiKey string
	id string
	seasonNumber string
}

func (r ApiAPISubtitlesApiKeyIdSeasonNumberGetRequest) Execute() (*SubtitleData, *http.Response, error) {
	return r.ApiService.APISubtitlesApiKeyIdSeasonNumberGetExecute(r)
}

/*
APISubtitlesApiKeyIdSeasonNumberGet Method for APISubtitlesApiKeyIdSeasonNumberGet

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param apiKey
 @param id
 @param seasonNumber
 @return ApiAPISubtitlesApiKeyIdSeasonNumberGetRequest
*/
func (a *MoviesApiApiService) APISubtitlesApiKeyIdSeasonNumberGet(ctx context.Context, apiKey string, id string, seasonNumber string) ApiAPISubtitlesApiKeyIdSeasonNumberGetRequest {
	return ApiAPISubtitlesApiKeyIdSeasonNumberGetRequest{
		ApiService: a,
		ctx: ctx,
		apiKey: apiKey,
		id: id,
		seasonNumber: seasonNumber,
	}
}

// Execute executes the request
//  @return SubtitleData
func (a *MoviesApiApiService) APISubtitlesApiKeyIdSeasonNumberGetExecute(r ApiAPISubtitlesApiKeyIdSeasonNumberGetRequest) (*SubtitleData, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *SubtitleData
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "MoviesApiApiService.APISubtitlesApiKeyIdSeasonNumberGet")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/API/Subtitles/{apiKey}/{id}/{seasonNumber}"
	localVarPath = strings.Replace(localVarPath, "{"+"apiKey"+"}", url.PathEscape(parameterToString(r.apiKey, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterToString(r.id, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"seasonNumber"+"}", url.PathEscape(parameterToString(r.seasonNumber, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"text/plain", "application/json", "text/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiAPITop250MoviesApiKeyGetRequest struct {
	ctx context.Context
	ApiService *MoviesApiApiService
	apiKey string
}

func (r ApiAPITop250MoviesApiKeyGetRequest) Execute() (*Top250Data, *http.Response, error) {
	return r.ApiService.APITop250MoviesApiKeyGetExecute(r)
}

/*
APITop250MoviesApiKeyGet Method for APITop250MoviesApiKeyGet

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param apiKey
 @return ApiAPITop250MoviesApiKeyGetRequest
*/
func (a *MoviesApiApiService) APITop250MoviesApiKeyGet(ctx context.Context, apiKey string) ApiAPITop250MoviesApiKeyGetRequest {
	return ApiAPITop250MoviesApiKeyGetRequest{
		ApiService: a,
		ctx: ctx,
		apiKey: apiKey,
	}
}

// Execute executes the request
//  @return Top250Data
func (a *MoviesApiApiService) APITop250MoviesApiKeyGetExecute(r ApiAPITop250MoviesApiKeyGetRequest) (*Top250Data, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Top250Data
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "MoviesApiApiService.APITop250MoviesApiKeyGet")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/API/Top250Movies/{apiKey}"
	localVarPath = strings.Replace(localVarPath, "{"+"apiKey"+"}", url.PathEscape(parameterToString(r.apiKey, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"text/plain", "application/json", "text/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiAPITop250TVsApiKeyGetRequest struct {
	ctx context.Context
	ApiService *MoviesApiApiService
	apiKey string
}

func (r ApiAPITop250TVsApiKeyGetRequest) Execute() (*Top250Data, *http.Response, error) {
	return r.ApiService.APITop250TVsApiKeyGetExecute(r)
}

/*
APITop250TVsApiKeyGet Method for APITop250TVsApiKeyGet

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param apiKey
 @return ApiAPITop250TVsApiKeyGetRequest
*/
func (a *MoviesApiApiService) APITop250TVsApiKeyGet(ctx context.Context, apiKey string) ApiAPITop250TVsApiKeyGetRequest {
	return ApiAPITop250TVsApiKeyGetRequest{
		ApiService: a,
		ctx: ctx,
		apiKey: apiKey,
	}
}

// Execute executes the request
//  @return Top250Data
func (a *MoviesApiApiService) APITop250TVsApiKeyGetExecute(r ApiAPITop250TVsApiKeyGetRequest) (*Top250Data, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Top250Data
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "MoviesApiApiService.APITop250TVsApiKeyGet")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/API/Top250TVs/{apiKey}"
	localVarPath = strings.Replace(localVarPath, "{"+"apiKey"+"}", url.PathEscape(parameterToString(r.apiKey, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"text/plain", "application/json", "text/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiAPITrailerApiKeyIdGetRequest struct {
	ctx context.Context
	ApiService *MoviesApiApiService
	apiKey string
	id string
}

func (r ApiAPITrailerApiKeyIdGetRequest) Execute() (*TrailerData, *http.Response, error) {
	return r.ApiService.APITrailerApiKeyIdGetExecute(r)
}

/*
APITrailerApiKeyIdGet Method for APITrailerApiKeyIdGet

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param apiKey
 @param id
 @return ApiAPITrailerApiKeyIdGetRequest
*/
func (a *MoviesApiApiService) APITrailerApiKeyIdGet(ctx context.Context, apiKey string, id string) ApiAPITrailerApiKeyIdGetRequest {
	return ApiAPITrailerApiKeyIdGetRequest{
		ApiService: a,
		ctx: ctx,
		apiKey: apiKey,
		id: id,
	}
}

// Execute executes the request
//  @return TrailerData
func (a *MoviesApiApiService) APITrailerApiKeyIdGetExecute(r ApiAPITrailerApiKeyIdGetRequest) (*TrailerData, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *TrailerData
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "MoviesApiApiService.APITrailerApiKeyIdGet")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/API/Trailer/{apiKey}/{id}"
	localVarPath = strings.Replace(localVarPath, "{"+"apiKey"+"}", url.PathEscape(parameterToString(r.apiKey, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterToString(r.id, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"text/plain", "application/json", "text/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiAPIUsageApiKeyGetRequest struct {
	ctx context.Context
	ApiService *MoviesApiApiService
	apiKey string
}

func (r ApiAPIUsageApiKeyGetRequest) Execute() (*UsageData, *http.Response, error) {
	return r.ApiService.APIUsageApiKeyGetExecute(r)
}

/*
APIUsageApiKeyGet Method for APIUsageApiKeyGet

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param apiKey
 @return ApiAPIUsageApiKeyGetRequest
*/
func (a *MoviesApiApiService) APIUsageApiKeyGet(ctx context.Context, apiKey string) ApiAPIUsageApiKeyGetRequest {
	return ApiAPIUsageApiKeyGetRequest{
		ApiService: a,
		ctx: ctx,
		apiKey: apiKey,
	}
}

// Execute executes the request
//  @return UsageData
func (a *MoviesApiApiService) APIUsageApiKeyGetExecute(r ApiAPIUsageApiKeyGetRequest) (*UsageData, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *UsageData
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "MoviesApiApiService.APIUsageApiKeyGet")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/API/Usage/{apiKey}"
	localVarPath = strings.Replace(localVarPath, "{"+"apiKey"+"}", url.PathEscape(parameterToString(r.apiKey, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"text/plain", "application/json", "text/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiAPIUserRatingsApiKeyIdGetRequest struct {
	ctx context.Context
	ApiService *MoviesApiApiService
	apiKey string
	id string
}

func (r ApiAPIUserRatingsApiKeyIdGetRequest) Execute() (*UserRatingData, *http.Response, error) {
	return r.ApiService.APIUserRatingsApiKeyIdGetExecute(r)
}

/*
APIUserRatingsApiKeyIdGet Method for APIUserRatingsApiKeyIdGet

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param apiKey
 @param id
 @return ApiAPIUserRatingsApiKeyIdGetRequest
*/
func (a *MoviesApiApiService) APIUserRatingsApiKeyIdGet(ctx context.Context, apiKey string, id string) ApiAPIUserRatingsApiKeyIdGetRequest {
	return ApiAPIUserRatingsApiKeyIdGetRequest{
		ApiService: a,
		ctx: ctx,
		apiKey: apiKey,
		id: id,
	}
}

// Execute executes the request
//  @return UserRatingData
func (a *MoviesApiApiService) APIUserRatingsApiKeyIdGetExecute(r ApiAPIUserRatingsApiKeyIdGetRequest) (*UserRatingData, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *UserRatingData
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "MoviesApiApiService.APIUserRatingsApiKeyIdGet")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/API/UserRatings/{apiKey}/{id}"
	localVarPath = strings.Replace(localVarPath, "{"+"apiKey"+"}", url.PathEscape(parameterToString(r.apiKey, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterToString(r.id, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"text/plain", "application/json", "text/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiAPIYouTubeApiKeyVGetRequest struct {
	ctx context.Context
	ApiService *MoviesApiApiService
	apiKey string
	v string
}

func (r ApiAPIYouTubeApiKeyVGetRequest) Execute() (*YouTubeData, *http.Response, error) {
	return r.ApiService.APIYouTubeApiKeyVGetExecute(r)
}

/*
APIYouTubeApiKeyVGet Method for APIYouTubeApiKeyVGet

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param apiKey
 @param v
 @return ApiAPIYouTubeApiKeyVGetRequest
*/
func (a *MoviesApiApiService) APIYouTubeApiKeyVGet(ctx context.Context, apiKey string, v string) ApiAPIYouTubeApiKeyVGetRequest {
	return ApiAPIYouTubeApiKeyVGetRequest{
		ApiService: a,
		ctx: ctx,
		apiKey: apiKey,
		v: v,
	}
}

// Execute executes the request
//  @return YouTubeData
func (a *MoviesApiApiService) APIYouTubeApiKeyVGetExecute(r ApiAPIYouTubeApiKeyVGetRequest) (*YouTubeData, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *YouTubeData
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "MoviesApiApiService.APIYouTubeApiKeyVGet")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/API/YouTube/{apiKey}/{v}"
	localVarPath = strings.Replace(localVarPath, "{"+"apiKey"+"}", url.PathEscape(parameterToString(r.apiKey, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"v"+"}", url.PathEscape(parameterToString(r.v, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"text/plain", "application/json", "text/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiAPIYouTubePlaylistApiKeyListGetRequest struct {
	ctx context.Context
	ApiService *MoviesApiApiService
	apiKey string
	list string
}

func (r ApiAPIYouTubePlaylistApiKeyListGetRequest) Execute() (*YouTubePlaylistData, *http.Response, error) {
	return r.ApiService.APIYouTubePlaylistApiKeyListGetExecute(r)
}

/*
APIYouTubePlaylistApiKeyListGet Method for APIYouTubePlaylistApiKeyListGet

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param apiKey
 @param list
 @return ApiAPIYouTubePlaylistApiKeyListGetRequest
*/
func (a *MoviesApiApiService) APIYouTubePlaylistApiKeyListGet(ctx context.Context, apiKey string, list string) ApiAPIYouTubePlaylistApiKeyListGetRequest {
	return ApiAPIYouTubePlaylistApiKeyListGetRequest{
		ApiService: a,
		ctx: ctx,
		apiKey: apiKey,
		list: list,
	}
}

// Execute executes the request
//  @return YouTubePlaylistData
func (a *MoviesApiApiService) APIYouTubePlaylistApiKeyListGetExecute(r ApiAPIYouTubePlaylistApiKeyListGetRequest) (*YouTubePlaylistData, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *YouTubePlaylistData
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "MoviesApiApiService.APIYouTubePlaylistApiKeyListGet")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/API/YouTubePlaylist/{apiKey}/{list}"
	localVarPath = strings.Replace(localVarPath, "{"+"apiKey"+"}", url.PathEscape(parameterToString(r.apiKey, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"list"+"}", url.PathEscape(parameterToString(r.list, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"text/plain", "application/json", "text/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiAPIYouTubeTrailerApiKeyIdGetRequest struct {
	ctx context.Context
	ApiService *MoviesApiApiService
	apiKey string
	id string
}

func (r ApiAPIYouTubeTrailerApiKeyIdGetRequest) Execute() (*YouTubeTrailerData, *http.Response, error) {
	return r.ApiService.APIYouTubeTrailerApiKeyIdGetExecute(r)
}

/*
APIYouTubeTrailerApiKeyIdGet Method for APIYouTubeTrailerApiKeyIdGet

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param apiKey
 @param id
 @return ApiAPIYouTubeTrailerApiKeyIdGetRequest
*/
func (a *MoviesApiApiService) APIYouTubeTrailerApiKeyIdGet(ctx context.Context, apiKey string, id string) ApiAPIYouTubeTrailerApiKeyIdGetRequest {
	return ApiAPIYouTubeTrailerApiKeyIdGetRequest{
		ApiService: a,
		ctx: ctx,
		apiKey: apiKey,
		id: id,
	}
}

// Execute executes the request
//  @return YouTubeTrailerData
func (a *MoviesApiApiService) APIYouTubeTrailerApiKeyIdGetExecute(r ApiAPIYouTubeTrailerApiKeyIdGetRequest) (*YouTubeTrailerData, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *YouTubeTrailerData
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "MoviesApiApiService.APIYouTubeTrailerApiKeyIdGet")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/API/YouTubeTrailer/{apiKey}/{id}"
	localVarPath = strings.Replace(localVarPath, "{"+"apiKey"+"}", url.PathEscape(parameterToString(r.apiKey, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterToString(r.id, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"text/plain", "application/json", "text/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiLangAPIReportApiKeyIdGetRequest struct {
	ctx context.Context
	ApiService *MoviesApiApiService
	lang string
	id string
	apiKey string
}

func (r ApiLangAPIReportApiKeyIdGetRequest) Execute() (*http.Response, error) {
	return r.ApiService.LangAPIReportApiKeyIdGetExecute(r)
}

/*
LangAPIReportApiKeyIdGet Method for LangAPIReportApiKeyIdGet

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param lang
 @param id
 @param apiKey
 @return ApiLangAPIReportApiKeyIdGetRequest
*/
func (a *MoviesApiApiService) LangAPIReportApiKeyIdGet(ctx context.Context, lang string, id string, apiKey string) ApiLangAPIReportApiKeyIdGetRequest {
	return ApiLangAPIReportApiKeyIdGetRequest{
		ApiService: a,
		ctx: ctx,
		lang: lang,
		id: id,
		apiKey: apiKey,
	}
}

// Execute executes the request
func (a *MoviesApiApiService) LangAPIReportApiKeyIdGetExecute(r ApiLangAPIReportApiKeyIdGetRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "MoviesApiApiService.LangAPIReportApiKeyIdGet")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/{lang}/API/Report/{apiKey}/{id}"
	localVarPath = strings.Replace(localVarPath, "{"+"lang"+"}", url.PathEscape(parameterToString(r.lang, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterToString(r.id, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"apiKey"+"}", url.PathEscape(parameterToString(r.apiKey, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiLangAPIReportApiKeyIdOptionsGetRequest struct {
	ctx context.Context
	ApiService *MoviesApiApiService
	lang string
	id string
	options string
	apiKey string
}

func (r ApiLangAPIReportApiKeyIdOptionsGetRequest) Execute() (*http.Response, error) {
	return r.ApiService.LangAPIReportApiKeyIdOptionsGetExecute(r)
}

/*
LangAPIReportApiKeyIdOptionsGet Method for LangAPIReportApiKeyIdOptionsGet

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param lang
 @param id
 @param options
 @param apiKey
 @return ApiLangAPIReportApiKeyIdOptionsGetRequest
*/
func (a *MoviesApiApiService) LangAPIReportApiKeyIdOptionsGet(ctx context.Context, lang string, id string, options string, apiKey string) ApiLangAPIReportApiKeyIdOptionsGetRequest {
	return ApiLangAPIReportApiKeyIdOptionsGetRequest{
		ApiService: a,
		ctx: ctx,
		lang: lang,
		id: id,
		options: options,
		apiKey: apiKey,
	}
}

// Execute executes the request
func (a *MoviesApiApiService) LangAPIReportApiKeyIdOptionsGetExecute(r ApiLangAPIReportApiKeyIdOptionsGetRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "MoviesApiApiService.LangAPIReportApiKeyIdOptionsGet")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/{lang}/API/Report/{apiKey}/{id}/{options}"
	localVarPath = strings.Replace(localVarPath, "{"+"lang"+"}", url.PathEscape(parameterToString(r.lang, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterToString(r.id, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"options"+"}", url.PathEscape(parameterToString(r.options, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"apiKey"+"}", url.PathEscape(parameterToString(r.apiKey, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiLangAPITitleApiKeyIdGetRequest struct {
	ctx context.Context
	ApiService *MoviesApiApiService
	lang string
	id string
	apiKey string
}

func (r ApiLangAPITitleApiKeyIdGetRequest) Execute() (*TitleData, *http.Response, error) {
	return r.ApiService.LangAPITitleApiKeyIdGetExecute(r)
}

/*
LangAPITitleApiKeyIdGet Method for LangAPITitleApiKeyIdGet

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param lang
 @param id
 @param apiKey
 @return ApiLangAPITitleApiKeyIdGetRequest
*/
func (a *MoviesApiApiService) LangAPITitleApiKeyIdGet(ctx context.Context, lang string, id string, apiKey string) ApiLangAPITitleApiKeyIdGetRequest {
	return ApiLangAPITitleApiKeyIdGetRequest{
		ApiService: a,
		ctx: ctx,
		lang: lang,
		id: id,
		apiKey: apiKey,
	}
}

// Execute executes the request
//  @return TitleData
func (a *MoviesApiApiService) LangAPITitleApiKeyIdGetExecute(r ApiLangAPITitleApiKeyIdGetRequest) (*TitleData, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *TitleData
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "MoviesApiApiService.LangAPITitleApiKeyIdGet")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/{lang}/API/Title/{apiKey}/{id}"
	localVarPath = strings.Replace(localVarPath, "{"+"lang"+"}", url.PathEscape(parameterToString(r.lang, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterToString(r.id, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"apiKey"+"}", url.PathEscape(parameterToString(r.apiKey, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"text/plain", "application/json", "text/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiLangAPITitleApiKeyIdOptionsGetRequest struct {
	ctx context.Context
	ApiService *MoviesApiApiService
	lang string
	apiKey string
	id string
	options string
}

func (r ApiLangAPITitleApiKeyIdOptionsGetRequest) Execute() (*TitleData, *http.Response, error) {
	return r.ApiService.LangAPITitleApiKeyIdOptionsGetExecute(r)
}

/*
LangAPITitleApiKeyIdOptionsGet Method for LangAPITitleApiKeyIdOptionsGet

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param lang
 @param apiKey
 @param id
 @param options
 @return ApiLangAPITitleApiKeyIdOptionsGetRequest
*/
func (a *MoviesApiApiService) LangAPITitleApiKeyIdOptionsGet(ctx context.Context, lang string, apiKey string, id string, options string) ApiLangAPITitleApiKeyIdOptionsGetRequest {
	return ApiLangAPITitleApiKeyIdOptionsGetRequest{
		ApiService: a,
		ctx: ctx,
		lang: lang,
		apiKey: apiKey,
		id: id,
		options: options,
	}
}

// Execute executes the request
//  @return TitleData
func (a *MoviesApiApiService) LangAPITitleApiKeyIdOptionsGetExecute(r ApiLangAPITitleApiKeyIdOptionsGetRequest) (*TitleData, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *TitleData
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "MoviesApiApiService.LangAPITitleApiKeyIdOptionsGet")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/{lang}/API/Title/{apiKey}/{id}/{options}"
	localVarPath = strings.Replace(localVarPath, "{"+"lang"+"}", url.PathEscape(parameterToString(r.lang, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"apiKey"+"}", url.PathEscape(parameterToString(r.apiKey, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterToString(r.id, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"options"+"}", url.PathEscape(parameterToString(r.options, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"text/plain", "application/json", "text/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiLangAPIWikipediaApiKeyIdGetRequest struct {
	ctx context.Context
	ApiService *MoviesApiApiService
	lang string
	apiKey string
	id string
}

func (r ApiLangAPIWikipediaApiKeyIdGetRequest) Execute() (*WikipediaData, *http.Response, error) {
	return r.ApiService.LangAPIWikipediaApiKeyIdGetExecute(r)
}

/*
LangAPIWikipediaApiKeyIdGet Method for LangAPIWikipediaApiKeyIdGet

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param lang
 @param apiKey
 @param id
 @return ApiLangAPIWikipediaApiKeyIdGetRequest
*/
func (a *MoviesApiApiService) LangAPIWikipediaApiKeyIdGet(ctx context.Context, lang string, apiKey string, id string) ApiLangAPIWikipediaApiKeyIdGetRequest {
	return ApiLangAPIWikipediaApiKeyIdGetRequest{
		ApiService: a,
		ctx: ctx,
		lang: lang,
		apiKey: apiKey,
		id: id,
	}
}

// Execute executes the request
//  @return WikipediaData
func (a *MoviesApiApiService) LangAPIWikipediaApiKeyIdGetExecute(r ApiLangAPIWikipediaApiKeyIdGetRequest) (*WikipediaData, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *WikipediaData
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "MoviesApiApiService.LangAPIWikipediaApiKeyIdGet")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/{lang}/API/Wikipedia/{apiKey}/{id}"
	localVarPath = strings.Replace(localVarPath, "{"+"lang"+"}", url.PathEscape(parameterToString(r.lang, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"apiKey"+"}", url.PathEscape(parameterToString(r.apiKey, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterToString(r.id, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"text/plain", "application/json", "text/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}
